# signal_sample

dft関数、idft関数は見ての通り離散フーリエ変換、逆変換です。

# dft f(t)→F(w)　　　(t, wはインデックス値、配列長はlength)

       F(w) = Σ f(t) exp (-2 * π * i * w * t / length)
      （総和は0 <= t <= (length - 1)の範囲、iは虚数）
       
# idft F(w)→f(t)　　(t, wはインデックス値、配列長はlength)

       f(t) = Σ F(w) exp (2 * π * i * w * t / length)
      （総和は0 <= w <= (length - 1)の範囲、iは虚数）      

# idftは全体係数に1 / Nを掛けることもありますがここではやりません。


      
これらを効率化したものがfft,ifftです。

# fft f(t)→F(w)　　　(t, wはインデックス値、配列長はlength)

　　　　lengthが偶数であり「2M」であるとします。

       F(w) = Σ f(t) exp (-2 * π * i * w * t / length)
            = Σ f(t) exp (-2 * π * i * w * t / (2M) )
          （総和は0 <= t <= (length - 1)の範囲、iは虚数）  
       
       さらに変形(インデックス値が偶数であるものと奇数であるものを分離)して     
       
       F(w) = Σ f(2 * t) exp (-2 * π * i * w * (2 * t) / (2M) ) + 
              Σ f(2 * t + 1) exp (-2 * π * i * w * (2 * t + 1) / (2M) )
          （総和は0 <= t <= (M - 1)の範囲、iは虚数）
       
       さらに、第二項のうち、tに関係しない部分をΣの係数にすると以下のようになる。       
              
       F(w) = Σ f(2 * t) exp (-2 * π * i * w * (2 * t) / (2M) ) + 
              exp(-2 * π * i * w / (2M) )Σ f(2 * t + 1) exp (-2 * π * i * w * (2 * t) / (2M)      
            = Σ f(2 * t) exp (-2 * π * i * w * t) / M ) + 
              exp(-π * i * w / M)Σ f(2 * t + 1) exp (-2 * π * i * w * t / M)      
          （総和は0 <= t <= (M - 1)の範囲、iは虚数）

       ここで以下の通り、fを二つに分離する。
       g(t) = f(2 * t)　　　　　　　　インデックス値が偶数のもの
       h(t) = f(2 * t + 1)　　　　　　インデックス値が奇数のもの
       （配列長は当然Mとなる）
       
       すると前式は下のようになる。
       
       F(w)= Σ g(t) exp (-2 * π * i * w * t / M ) + 
              exp(-π * i * w / M)Σ h(t) exp (-2 * π * i * w * t / M)  
          （総和は0 <= t <= (M - 1)の範囲、iは虚数）
       
       見ての通り、第一項はg(t)についてのフーリエ変換、第二項の一部はh(t)についてのフーリエ変換に見える。
       ただし、これは0 <= w <= M - 1のときまでである。 M <= wのときは別に考えなければならない。
       w = M + vと置けば、以下のように式変形できる。
       
       F(w)= Σ g(t) exp (-2 * π * i * (M + v) * t) / M ) + 
              exp(-π * i * (M + v) / M)Σ h(t) exp (-2 * π * i * (M + v) * t / M)
           = Σ g(t) exp (-2 * π * i * v * t) / M ) + 
              exp(- π* i) * exp(-π * i * v / M)Σ h(t) exp (-2 * π * i * v * t / M) 
           = Σ g(t) exp (-2 * π * i * v * t) / M ) - 
              exp(-π * i * v / M)Σ h(t) exp (-2 * π * i * v * t / M)            
          （総和は0 <= t <= (M - 1)の範囲、iは虚数）   
      
       見ての通り、これは0 <= w <= M - 1のときにおける第二項の符号が正から負に変わっただけである。
       総じて以下のことが言える。g(t),h(t)のフーリエ変換をそれぞれG(w),H(w)とする。
       
       F(w) = G(w) + exp(-π * i * w / M) H(w)  
       F(w + M) = G(w) - exp(-π * i * w / M) H(w) 
        (0 <= w <= M - 1)
        
       これは再帰関数で実装できる。逆変換も同様である。当然ながら、配列長が奇数の場合は適用できないので通常のdft相当処理をする。
       
       
          
